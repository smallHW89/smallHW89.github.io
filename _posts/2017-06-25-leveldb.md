---
date: 2017-06-25 13:42
status: public
title: levelDb学习笔记-1
---

## 参考资料
[leveldb源码分析系列](http://blog.csdn.net/sparkliang/article/category/1342001)

##  
leveldb 不提供网络相关部分，不是一个server，是一个单机的存储lib， lib中会采用多线程技术

## util/ arena.h arena.cc
class Arena ， 简单的内存池

## db/  skiplist.h
class SkipList 跳表，节点有序，查找lgN复杂度，相对于平衡二茶树，红黑树实现简单


## db/  memtable.h memtable.cc 

class MemTable 类, 内存表结构，
   用skip_list结构存储key-value（按key顺序排列) 
   用内存池，新增的key-value 从内存池分配空间
   提供add接口，接口带sequenceNum，也就是版本号；用于新增key-value, 删除key(leveldb删除key 直接新插入这个key，标记为删除)
   提供get接口，查找某个key

   InteralKey 内部key的组成   |UserKey(string)|SequnceNum|valueType| 
   这样UserKey之间有序， 同一个UserKey 的不同版本号 有序

class MemTableIterator 针对MemTable 提供迭代器
    MemTableIterator 继承于 Iterator, 内部用SkipList的接口

## include/leveldb  iterator.h 

class Iterator 纯虚类，指定接口

##  include/leveldb/table.h   db/table.h

class Table

A Table is a sorted map from strings to strings.  Tables are immutable and persistent.  A Table may be safely accessed from
multiple threads without external synchronization.          


## log文件
1. levelDb 更新数据时 采用先写log（WL 预写log方式) , 然后更新内存memtable， 这种技术很多系统种采用

1)log顺序写 append

2)进程异常时,内存数据丢失时， 可以从log种恢复

2. PS: leveldb 可以指定写log的方式 async下写Log文件不会立即刷到磁盘，由OS负责. sync方式下，写LOG后调用sync接口把数据刷到磁盘

3. source file: log_writer.h log_writer.cc log_reader.h log_reader.cc

4. block_size 32K  1条Log可以占用多个block , 一个block里面也可以包含多个Log


## SSTable 文件
doc/table_format.txt 描述了文件的逻辑结构

![从网上借用的一张sstable-file的逻辑结构描述图](../images/leveldb_format.JPG)


source code :   block_builder.h ,block_builder.cc






